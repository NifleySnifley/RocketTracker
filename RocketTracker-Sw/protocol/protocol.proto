syntax = "proto2";

enum TalkerID {
  TalkerReserved = 0;
  Tracker_V2 = 1;
  Tracker_V3 = 2;
  Receiver_V1 = 3;
  Basestation = 4;
}

enum LinkID {
  LinkReserved = 0;
  USBSerial = 1;
  LoRa = 2;
}

message GPS {
  required double lat = 1;        // Latitude in degrees North
  required double lon = 2;        // Longitude in degrees West
  required double alt = 3;        // Altitude in meters above SEA LEVEL
  required uint32 utc_time = 4;   // UTC time in NMEA hhmmsssss as an int
  optional uint32 sats_used = 5;  // Satellites used for fix
  optional uint32 fix_status = 6; // NMEA fix status (0-6)
}

message Battery {
  required float battery_voltage = 1;
  required float percentage = 3;
//  required bool charging = 2;
}

message Altitude {
  required float alt_m = 1;
  optional float v_speed = 2;
}

message Orientation {
  required float orientation_x = 1;
  required float orientation_y = 2;
  required float orientation_z = 3;
}

enum AlertType {
  ALT_Apogee = 0;  // Reached apogee
  ALT_LowBatt = 1; // Battery < 50%
  ALT_CritBatt = 6; // Battery < 20%
  ALT_Landed = 2;  // No major movement for X secs (configurable?)
  ALT_Liftoff = 3; // Large forward accel detected
  ALT_Log50 = 4;   // Log memory 50% full warning (IDEA: Maybe have it reduce
                   // logging speed as it fills? inversely slower?)
  ALT_LogFull = 5; // Log full, logging stopped!

  ALT_Error = 128; // Internal tracker error, error code specified in data
}

message Alert {
  required AlertType type = 1;
  optional uint32 data = 2;
}

message RadioRxStatus {
  required float RSSI = 1;
  required float SNR = 2;
  required bool crc_valid = 3;
}

message LogStatus {
  required uint32 log_size = 1;
  required uint32 log_maxsize = 2;
  optional float cur_logging_hz = 3;
  required bool is_armed = 4;
  required bool is_auto = 5;
}

// Info (telemetry)
// Status
// Cmd
// Resp
enum DatumTypeID {
  // Telemetry
  INFO_Blank = 0;
  INFO_Raw = 1;
  INFO_Battery = 2;
  INFO_GPS = 3;
  INFO_Altitude = 4;
  INFO_Orientation = 5;
  INFO_Alert = 6;
  INFO_LogStatus = 7;

  // Receiver
  STATUS_RadioRxStatus = 64;

  // Commands & Responses
  CMD_Ping = 128; // -> RESP_Ping
  RESP_Ping = 129;

  // TODO: Integrate commands to: arm logging, manually start logging, stop logging
  CMD_ConfigureLogging = 130; // NO_BODY -> RESP_StartLog
  RESP_ConfigureLogging = 131; // Resp_BasicError

  CMD_EraseLog = 134; // -> RESP_EraseLog
  RESP_EraseLog = 135; // Resp_BasicError

  CMD_DownloadLog = 136; // NO_BODY -> N * (RESP_DownloadLog_Segment)
  RESP_DownloadLog = 140; // Resp_BasicError -> N * (RESP_DownloadLog_Segment)
  RESP_DownloadLog_Segment = 137; // Resp_DownloadLog_Segment
  ACK_Download_Complete = 138; //
  //ACK_DownloadLog_Segment = 141;
  // ACK_Download_Resend = 141; // TODO: Implement a mechanism for resending portions of the log!

  CMD_LogStatus = 139; // NO_BODY -> INFO_LogStatus
}

enum LoggingMode {
    Stopped = 0;
    Armed = 1;
    ManualHz = 2;
}

message Command_ConfigureLogging {
    required LoggingMode setting = 1;
    optional uint32 parameter = 2; // Used for ManualHz
}

message Resp_BasicError {
  optional uint32 error = 1;
}

// Log download:
// -> CMD_StopLog 
// <- RESP_StopLog (Resp_BasicError)
// -> CMD_LogStatus 
// <- INFO_LogStatus
// -> CMD_DownloadLog
// <- ACK_DownloadLog_Segment * N
// IGNORE IGNORE IGNORE IGNORE IGNORE-> ACK_DownloadLog_Segment // TBD whether this will be implemented!!!
// <- ACK_Download_Complete
// -> ACK_Download_Complete

message Resp_DownloadLog_Segment {
  required uint32 start_address = 1;
  required uint32 length = 2;
  required bytes data = 3; // 4096 bytes max
  // IS uint16!!
  required uint32 segment_crc16 = 4; // Same as for LoRa, check this on the receiving end

  optional uint32 error = 5;
}

message Acknowledgement_Download_Complete {
  // IS uint16!!
  required uint32 log_crc16 = 1;
  optional uint32 error = 2;
}

// Used to negotiate the capacity of frames on this link
message Command_Ping {
  required LinkID link = 1;
}
message Resp_Ping {
  required LinkID link = 1;
}

enum EraseType {
    Erase_Log = 0; // Deletes the current log and starts a new one
    Erase_Clean = 1; // Resets log to defaults, overrides wear leveling, and wipes the entire flash memory
}
message Command_EraseLog {
    required EraseType type = 1;
}